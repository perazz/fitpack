<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fitpack: Surface Fitting Theory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init()
        </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fitpack
   </div>
   <div id="projectbrief">Modern Fortran library for curve and surface fitting with splines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('theory_surface_fitting.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Surface Fitting Theory</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2fitpack_2fitpack_2doc_2theory__surface__fitting"></a></p>
<p>This page describes the mathematical foundations for bivariate spline fitting in FITPACK: extending the one-dimensional B-spline framework to approximate surfaces \( z = s(x, y) \) defined over a rectangular domain.</p>
<h1><a class="anchor" id="autotoc_md49"></a>
Tensor Product Splines</h1>
<p>A bivariate spline on the rectangular domain \( [a, b] \times [c, d] \) is defined as a tensor product of univariate B-splines:</p>
<p class="formulaDsp">
\[    s(x, y) = \sum_{i=1}^{n_x - k_x - 1} \sum_{j=1}^{n_y - k_y - 1}
    c_{ij} \, N_{i, k_x}(x) \, M_{j, k_y}(y)
\]
</p>
<p>where:</p>
<ul>
<li>\( N_{i, k_x}(x) \) are B-splines of degree \( k_x \) on the knot vector \( \mathbf{t}_x = (t_{x,1}, \ldots, t_{x, n_x}) \),</li>
<li>\( M_{j, k_y}(y) \) are B-splines of degree \( k_y \) on the knot vector \( \mathbf{t}_y = (t_{y,1}, \ldots, t_{y, n_y}) \),</li>
<li>\( c_{ij} \) are the \( (n_x - k_x - 1)(n_y - k_y - 1) \) unknown coefficients.</li>
</ul>
<p>The two knot vectors are independent: the number of knots and their placement can differ between the \( x \)- and \( y \)-directions. In FITPACK, both degrees default to \( k_x = k_y = 3 \) (bicubic).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="theory_bsplines.html">B-Spline Foundations</a> for a detailed treatment of univariate B-spline basis functions and the de Boor&ndash;Cox recurrence.</dd></dl>
<h1><a class="anchor" id="autotoc_md50"></a>
Scattered Data Fitting (surfit)</h1>
<p>Given \( m \) scattered observations \( (x_i, y_i, z_i) \) with weights \( w_i &gt; 0 \), the goal is to find a tensor product spline \( s(x, y) \) that approximates the data while remaining smooth.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
The Observation Matrix</h2>
<p>Each data point \( (x_i, y_i) \) lies in a unique cell of the knot grid. For a given point, let \( \mu \) and \( \nu \) index the non-zero basis functions in \( x \) and \( y \), respectively. The observation matrix \( \mathbf{A} \) has entries:</p>
<p class="formulaDsp">
\[    A_{i, \ell} = N_{\mu, k_x}(x_i) \, M_{\nu, k_y}(y_i),
    \qquad \ell = (\mu - 1)(n_y - k_y - 1) + \nu
\]
</p>
<p>where the two-dimensional index pair \( (\mu, \nu) \) is mapped to a single column index \( \ell \). Each row of \( \mathbf{A} \) has at most \( (k_x + 1)(k_y + 1) \) non-zero entries, so the matrix is sparse.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Least-Squares Formulation</h2>
<p>The weighted least-squares problem is:</p>
<p class="formulaDsp">
\[    \min_{\mathbf{c}} \sum_{i=1}^{m} w_i^2
    \left( z_i - s(x_i, y_i) \right)^2
\]
</p>
<p>which in matrix form becomes  \( \min \| \mathbf{W}(\mathbf{z} -
\mathbf{A} \mathbf{c}) \|_2^2 \) with  \( \mathbf{W} =
\mathrm{diag}(w_1, \ldots, w_m) \).</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Smoothing Formulation</h2>
<p>The smoothing spline minimizes a roughness functional subject to a data fidelity constraint:</p>
<p class="formulaDsp">
\[    \min \iint \left[
        \left( \frac{\partial^2 s}{\partial x^2} \right)^2
        + 2 \left( \frac{\partial^2 s}{\partial x \, \partial y} \right)^2
        + \left( \frac{\partial^2 s}{\partial y^2} \right)^2
    \right] dx \, dy
    \quad \text{subject to} \quad
    \sum_{i=1}^{m} w_i^2 (z_i - s(x_i, y_i))^2 \leq S
\]
</p>
<p>where \( S \) is the smoothing factor. This is the bivariate analogue of the univariate smoothing spline problem.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Rank Deficiency</h2>
<p>When few data points fall within certain cells of the knot grid, the observation matrix \( \mathbf{A} \) can become rank deficient. This is more common in the bivariate case than in one dimension, because adding knots in both directions creates cells that may contain no data at all.</p>
<p>FITPACK handles rank deficiency using Householder QR factorization with column pivoting. When the numerical rank \( r \) of the system is less than the number of unknowns, the algorithm computes a minimum-norm solution among all least-squares solutions.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Adaptive Knot Placement</h2>
<p>Starting from a minimal knot set, <code>surfit</code> iteratively refines the approximation:</p>
<ol type="1">
<li>Fit the current knot configuration by solving the least-squares problem.</li>
<li>If the residual sum of squares exceeds \( S \), identify regions with large residuals.</li>
<li>Insert new knots alternately in the \( x \)- and \( y \)-directions, placing each knot where the local residual is largest.</li>
<li>Repeat until \( \sum w_i^2 (z_i - s(x_i, y_i))^2 \leq S \) is satisfied or a maximum knot count is reached.</li>
</ol>
<p>The alternating strategy ensures balanced refinement across both coordinate directions.</p>
<dl class="section see"><dt>See also</dt><dd>Dierckx, Ch. 5, &sect;5.3 (pp. 85&ndash;98)</dd></dl>
<h1><a class="anchor" id="autotoc_md56"></a>
Gridded Data Fitting (regrid)</h1>
<p>When the data lie on a rectangular grid \( z_{ji} = z(y_j, x_i) \) with \( i = 1, \ldots, m_x \) and \( j = 1, \ldots, m_y \), the problem has a Kronecker product structure that can be exploited for dramatic computational savings.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Kronecker Product Structure</h2>
<p>On a grid, the observation matrix factors as a Kronecker product:</p>
<p class="formulaDsp">
\[    \mathbf{A}_{\text{grid}} = \mathbf{B}_x \otimes \mathbf{B}_y
\]
</p>
<p>where \( \mathbf{B}_x \) is the \( m_x \times (n_x - k_x - 1) \) matrix of univariate B-spline values at the \( x \)-grid points, and \( \mathbf{B}_y \) is the \( m_y \times (n_y - k_y - 1) \) matrix at the \( y \)-grid points. The coefficient matrix conceptually satisfies:</p>
<p class="formulaDsp">
\[    \mathbf{C} = \mathbf{B}_x^{-1} \, \mathbf{Z} \, (\mathbf{B}_y^T)^{-1}
\]
</p>
<p>where \( \mathbf{Z} \) is the \( m_x \times m_y \) matrix of observed values and \( \mathbf{C} \) holds the spline coefficients.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Computational Advantage</h2>
<p>The factored form means the normal equations can be solved dimension by dimension rather than simultaneously:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Approach   </th><th class="markdownTableHeadNone">Complexity    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scattered (<code>surfit</code>)   </td><td class="markdownTableBodyNone">\( \mathcal{O}(m \cdot n_x \cdot n_y) \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Gridded (<code>regrid</code>)   </td><td class="markdownTableBodyNone">\( \mathcal{O}(m_x \cdot m_y \cdot (k_x + k_y)) \)   </td></tr>
</table>
<p>For a 100 x 100 grid with 20 knots in each direction, the gridded approach is roughly two orders of magnitude faster. <b>Always prefer <code>fitpack_grid_surface</code> when data lie on a rectangular grid.</b></p>
<p>The smoothing framework (roughness minimization subject to a fidelity constraint) is identical to the scattered case; only the numerical solution method differs.</p>
<dl class="section see"><dt>See also</dt><dd>Dierckx, Ch. 5, &sect;5.4 (pp. 98&ndash;103)</dd></dl>
<h1><a class="anchor" id="autotoc_md59"></a>
The Smoothing Norm</h1>
<p>For bivariate splines, the roughness measure used in the smoothing formulation is the thin-plate energy functional:</p>
<p class="formulaDsp">
\[    R[s] = \iint \left[
        \left( \frac{\partial^2 s}{\partial x^2} \right)^2
        + 2 \left( \frac{\partial^2 s}{\partial x \, \partial y} \right)^2
        + \left( \frac{\partial^2 s}{\partial y^2} \right)^2
    \right] dx \, dy
\]
</p>
<p>This is the natural extension of \( \int (s&#39;&#39;)^2 \, dx \) to two dimensions. It penalizes curvature equally in all directions and is invariant under rotation of the coordinate axes. The cross-derivative term \( (\partial^2 s / \partial x \, \partial y)^2 \) ensures that diagonal oscillations are penalized as well.</p>
<p>For a tensor product spline, this integral can be expressed as a quadratic form in the coefficients \( c_{ij} \), involving integrals of products of B-spline second derivatives. FITPACK computes these integrals analytically using the knot vectors.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
Choosing the Smoothing Factor</h1>
<p>The smoothing factor \( S \) controls the balance between fidelity and smoothness:</p>
<ul>
<li>** \( S = 0 \)**: Interpolation. The spline passes through every data point (requires enough knots to satisfy the interpolation conditions).</li>
<li>**Small \( S \)**: Close fit to the data, but the surface may exhibit spurious oscillations.</li>
<li>**Large \( S \)**: Very smooth surface that may underfit the data.</li>
</ul>
<h2><a class="anchor" id="autotoc_md61"></a>
Practical Guidelines</h2>
<p>For <b>scattered data</b> with unit weights ( \( w_i = 1 \)), a reasonable starting point is:</p>
<p class="formulaDsp">
\[    S \approx m
\]
</p>
<p>where \( m \) is the number of data points. This follows from the expectation that, for a good fit with normally distributed residuals, the sum of squared residuals should be \( \mathcal{O}(m) \).</p>
<p>For <b>gridded data</b> with unit weights, the analogous rule is:</p>
<p class="formulaDsp">
\[    S \approx m_x \cdot m_y
\]
</p>
<p>After fitting, inspect the mean squared error via the <code>mse()</code> method to assess fit quality. If the residual is too large, decrease \( S \); if the surface oscillates, increase \( S \).</p>
<p>When data have non-unit weights, interpret \( S \) relative to the weighted residual. Setting \( w_i = 1 / \sigma_i \) (where \( \sigma_i \) is the measurement standard deviation) makes the residual sum an approximate \( \chi^2 \) statistic, and \( S \approx m \) corresponds to a reduced \( \chi^2 \) of unity.</p>
<h1><a class="anchor" id="autotoc_md62"></a>
Parametric Surfaces</h1>
<p>For surfaces embedded in \( \mathbb{R}^d \) and parameterized by \( (u, v) \), each coordinate component is represented as a separate bivariate spline sharing common knot vectors:</p>
<p class="formulaDsp">
\[    s_l(u, v) = \sum_{i=1}^{n_u - k_u - 1} \sum_{j=1}^{n_v - k_v - 1}
    c_{ij}^{(l)} \, N_{i, k_u}(u) \, M_{j, k_v}(v),
    \qquad l = 1, \ldots, d
\]
</p>
<p>All \( d \) components share the same knot vectors \( \mathbf{t}_u \) and \( \mathbf{t}_v \), and the same spline degrees \( k_u \) and \( k_v \). Only the coefficient arrays \( c_{ij}^{(l)} \) differ between components.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Periodicity</h2>
<p>Either parameter direction (or both) may be periodic:</p>
<ul>
<li>**Periodic in \( u \)**: enforces \( s_l^{(p)}(u_{\min}, v) = s_l^{(p)}(u_{\max}, v) \) for \( p = 0, 1, \ldots, k_u - 1 \).</li>
<li>**Periodic in \( v \)**: enforces \( s_l^{(p)}(u, v_{\min}) = s_l^{(p)}(u, v_{\max}) \) for \( p = 0, 1, \ldots, k_v - 1 \).</li>
</ul>
<p>Periodicity is useful for closed surfaces such as cylinders and tori. The FITPACK routine <code>parsur</code> handles the general case.</p>
<dl class="section see"><dt>See also</dt><dd>Dierckx, Ch. 10, &sect;10.2 (pp. 241&ndash;254)</dd></dl>
<h1><a class="anchor" id="autotoc_md64"></a>
Summary</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Problem   </th><th class="markdownTableHeadNone">FITPACK Type   </th><th class="markdownTableHeadNone">Core Routine   </th><th class="markdownTableHeadNone">Key Advantage    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Scattered \( (x_i, y_i, z_i) \)   </td><td class="markdownTableBodyNone"><code>fitpack_surface</code>   </td><td class="markdownTableBodyNone"><code>surfit</code>   </td><td class="markdownTableBodyNone">Handles arbitrary point distributions    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Gridded \( z(y_j, x_i) \)   </td><td class="markdownTableBodyNone"><code>fitpack_grid_surface</code>   </td><td class="markdownTableBodyNone"><code>regrid</code>   </td><td class="markdownTableBodyNone">Kronecker structure, much faster    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Parametric \( \mathbf{r}(u, v) \)   </td><td class="markdownTableBodyNone"><code>fitpack_parametric_surface</code>   </td><td class="markdownTableBodyNone"><code>parsur</code>   </td><td class="markdownTableBodyNone">Surfaces in \( \mathbb{R}^d \)   </td></tr>
</table>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="tutorial_surface.html">Scattered Surface Fitting Tutorial</a> for code examples and practical usage </dd>
<dd>
<a class="el" href="tutorial_polar.html">Polar Domain Fitting Tutorial</a> for polar and spherical domain fitting </dd>
<dd>
<a class="el" href="book_reference.html">Book Reference Index</a> for a complete mapping of routines to book chapters </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
