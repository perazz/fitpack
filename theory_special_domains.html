<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fitpack: Polar and Spherical Domains</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init()
        </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fitpack
   </div>
   <div id="projectbrief">Modern Fortran library for curve and surface fitting with splines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('theory_special_domains.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Polar and Spherical Domains</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2fitpack_2fitpack_2doc_2theory__special__domains"></a></p>
<p>Fitting on non-rectangular domains&mdash;disc-shaped regions in the plane and the surface of a sphere&mdash;requires coordinate transformations that map the physical domain to a rectangular parameter space where tensor-product B-splines can be applied. These transformations introduce singularities (the origin of a disc, the poles of a sphere) where special continuity conditions must be imposed on the B-spline coefficients to ensure a smooth, single-valued result.</p>
<p>The presentation follows Dierckx (1993), Chapter 11.</p>
<h1><a class="anchor" id="autotoc_md65"></a>
Polar Coordinates</h1>
<h2><a class="anchor" id="autotoc_md66"></a>
The polar domain</h2>
<p>A general polar domain is the set of points \( (x, y) \) satisfying \( x^2 + y^2 \leq R(\theta)^2 \), where \( R(\theta) \) is a positive boundary function and \( \theta = \mathrm{atan2}(y, x) \). When \( R(\theta) \) is constant the domain is a circular disc.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Normalized polar transform</h2>
<p>FITPACK maps the physical coordinates \( (x, y) \) to normalized polar coordinates \( (u, v) \) via</p>
<p class="formulaDsp">
\[    x = u \, R(v) \cos v, \qquad y = u \, R(v) \sin v
\]
</p>
<p>with \( u \in [0, 1] \) and \( v \in [-\pi, \pi] \). The radial variable \( u \) runs from 0 (the origin) to 1 (the boundary), and \( v \) is the polar angle. In this parameter space the fitting problem becomes rectangular: find a tensor-product B-spline</p>
<p class="formulaDsp">
\[    s(u, v) = \sum_{i} \sum_{j} c_{ij} \, N_{i,k}(u) \, M_{j,k}(v)
\]
</p>
<p>that approximates the data in a weighted least-squares sense, subject to a smoothing condition or prescribed knot placement.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
FITPACK routines</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Routine   </th><th class="markdownTableHeadNone">Input   </th><th class="markdownTableHeadNone">Boundary    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>polar</code> (scattered)   </td><td class="markdownTableBodyNone">Arbitrary \( (x_i, y_i, z_i) \)   </td><td class="markdownTableBodyNone">General \( R(\theta) \) via function pointer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pogrid</code> (gridded)   </td><td class="markdownTableBodyNone">Data on a polar grid \( (u_i, v_j) \)   </td><td class="markdownTableBodyNone">Constant radius \( R \)   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md69"></a>
Continuity at the Origin</h1>
<h2><a class="anchor" id="autotoc_md70"></a>
The problem</h2>
<p>At \( u = 0 \) all values of the angle \( v \) map to the same physical point&mdash;the origin. A naive tensor-product spline in \( (u, v) \) would assign potentially different values to \( s(0, v) \) for different \( v \), producing a discontinuous or non-smooth surface at the centre of the disc.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
Continuity orders</h2>
<p>To obtain a physically meaningful result the B-spline coefficients near \( u = 0 \) must satisfy algebraic constraints that enforce continuity to the desired order.</p>
<p>** \( C^0 \) continuity.** The function value at the origin must be single-valued:</p>
<p class="formulaDsp">
\[    s(0, v) = c_0 \quad \text{(constant for all } v\text{)}
\]
</p>
<p>This is achieved by constraining all coefficients associated with the first radial B-spline to be equal.</p>
<p>** \( C^1 \) continuity.** In addition to \( C^0 \), the first radial derivative \( \partial s / \partial u \) at \( u = 0 \) must be consistent with a well-defined gradient vector in the \( (x, y) \) plane. Without this constraint, the directional derivative at the origin could depend on the approach angle in an unphysical way. The constraint takes the form of a linear relation among the coefficients of the first two radial B-splines.</p>
<p>** \( C^2 \) continuity.** The second radial derivatives must likewise be consistent with a well-defined Hessian at the origin. This imposes additional linear relations on the first three rows of coefficients.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Implementation in FITPACK</h2>
<p>The <code>bc_continuity_origin</code> parameter selects the continuity order:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><code>bc_continuity_origin</code>   </th><th class="markdownTableHeadNone">Continuity   </th><th class="markdownTableHeadNone">Available for    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">\( C^0 \)   </td><td class="markdownTableBodyNone">Scattered and gridded polar    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">\( C^1 \)   </td><td class="markdownTableBodyNone">Scattered and gridded polar    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">\( C^2 \) (default)   </td><td class="markdownTableBodyNone">Scattered polar only   </td></tr>
</table>
<p>The constraints are incorporated into the least-squares system during fitting, reducing the effective number of free coefficients near \( u = 0 \).</p>
<h1><a class="anchor" id="autotoc_md73"></a>
Boundary Conditions on the Disc Edge</h1>
<p>At the outer boundary \( u = 1 \) the following options are available:</p>
<ul>
<li><b>Extrapolation (default)</b>: No constraint is imposed at the boundary. The spline is free to take any value at \( u = 1 \).</li>
<li><b>Zero boundary</b>: The spline is forced to vanish on the boundary, \( s(1, v) = 0 \) for all \( v \). This is useful for problems where the function is known to be zero at the edge of the disc.</li>
</ul>
<p>For gridded polar fitting (<code>pogrid</code>), additional options control the behaviour at the origin:</p>
<ul>
<li><b>Prescribed origin value</b>: The value \( z_0 = s(0, v) \) can be supplied explicitly. It can be enforced exactly (<code>z0_exact = .true.</code>) or treated as an additional data point to be approximated.</li>
<li><b>Zero gradient at the origin</b>: Setting <code>z0_zero_gradient = .true.</code> enforces \( \nabla s(0, 0) = 0 \), creating a flat spot at the centre of the disc.</li>
</ul>
<h1><a class="anchor" id="autotoc_md74"></a>
Spherical Coordinates</h1>
<h2><a class="anchor" id="autotoc_md75"></a>
The spherical domain</h2>
<p>The unit sphere is parameterized by colatitude \( \theta \in [0, \pi] \) and longitude \( \phi \in [0, 2\pi] \). A scalar function on the sphere is represented as a tensor-product B-spline:</p>
<p class="formulaDsp">
\[    s(\theta, \phi) = \sum_{i} \sum_{j} c_{ij} \, N_{i,k}(\theta) \, M_{j,k}(\phi)
\]
</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Periodicity in longitude</h2>
<p>Because the sphere is periodic in \( \phi \), the spline must satisfy</p>
<p class="formulaDsp">
\[    s(\theta, 0) = s(\theta, 2\pi)
\]
</p>
<p>together with matching of all derivatives at \( \phi = 0 \) and \( \phi = 2\pi \). FITPACK enforces this by using a periodic knot vector and periodic B-spline basis in the \( \phi \) direction.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
FITPACK routines</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Routine   </th><th class="markdownTableHeadNone">Input    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>sphere</code> (scattered)   </td><td class="markdownTableBodyNone">Arbitrary \( (\theta_i, \phi_i, r_i) \) on the sphere    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>spgrid</code> (gridded)   </td><td class="markdownTableBodyNone">Data on a \( (\theta_i, \phi_j) \) grid   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md78"></a>
The Pole Problem</h1>
<h2><a class="anchor" id="autotoc_md79"></a>
Analogy with the origin problem</h2>
<p>The pole problem on the sphere is the direct analogue of the origin problem in polar coordinates. At the <b>north pole</b> ( \( \theta = 0 \)) and the <b>south pole</b> ( \( \theta = \pi \)), all longitudes \( \phi \) correspond to the same physical point. A naive tensor-product spline would allow different values of \( s(0, \phi) \) at different longitudes, producing a discontinuity at the pole.</p>
<h2><a class="anchor" id="autotoc_md80"></a>
Continuity conditions</h2>
<p>** \( C^0 \) continuity.** The function value at each pole must be single-valued:</p>
<p class="formulaDsp">
\[    s(0, \phi) = c_{\mathrm{NP}} \quad \text{(constant for all } \phi\text{)},
    \qquad
    s(\pi, \phi) = c_{\mathrm{SP}} \quad \text{(constant for all } \phi\text{)}
\]
</p>
<p>** \( C^1 \) continuity.** Additionally, the angular derivatives at each pole must be consistent with a well-defined gradient on the sphere. Without this constraint the directional derivative would depend on the approach azimuth in a manner incompatible with the smoothness of the underlying surface.</p>
<p>FITPACK enforces these conditions by imposing linear constraints on the B-spline coefficients near \( \theta = 0 \) and \( \theta = \pi \), reducing the number of free parameters at each pole.</p>
<h2><a class="anchor" id="autotoc_md81"></a>
Pole boundary conditions for gridded spheres</h2>
<p>For gridded spherical fitting (<code>spgrid</code>), the north and south poles have <b>independently configurable</b> boundary conditions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Setting   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>z0</code>   </td><td class="markdownTableBodyNone">Prescribed function value at the pole    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>exact</code>   </td><td class="markdownTableBodyNone">If <code>.true.</code>, the spline passes exactly through <code>z0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>continuity</code>   </td><td class="markdownTableBodyNone">Continuity order at the pole (0 = \( C^0 \), 1 = \( C^1 \))    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>zero_gradient</code>   </td><td class="markdownTableBodyNone">If <code>.true.</code>, enforce vanishing gradient at the pole   </td></tr>
</table>
<p>Each pole is configured independently via <code>BC_north_pole</code> and <code>BC_south_pole</code>, allowing asymmetric physical conditions (e.g., a known temperature at the north pole with a free south pole).</p>
<h1><a class="anchor" id="autotoc_md82"></a>
Practical Considerations</h1>
<ul>
<li><b>Arbitrary boundary shape</b>: The scattered polar fitter (<code>polar</code>) accepts a general boundary function \( R(\theta) \) through a function pointer, allowing fitting on non-circular disc-shaped domains. The gridded polar fitter (<code>pogrid</code>) requires a constant radius \( R \).</li>
<li><b>Evaluation grid layout</b>: The gridded sphere evaluation method <code>eval_many</code> returns an output array of shape \( (n_\phi, n_\theta) \), not paired points. This matches the tensor-product structure and allows efficient grid evaluation.</li>
<li><b>Independent pole settings</b>: The gridded sphere supports independent north and south pole boundary conditions, making it possible to impose different physical constraints at each pole without affecting the other.</li>
<li><b>Smoothing vs. interpolation</b>: All four routines (<code>polar</code>, <code>pogrid</code>, <code>sphere</code>, <code>spgrid</code>) support both smoothing and interpolation modes. In smoothing mode the continuity and boundary constraints are incorporated into the penalized least-squares problem; in interpolation mode they appear as hard constraints.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="theory_surface_fitting.html">Surface Fitting Theory</a> </dd>
<dd>
<a class="el" href="tutorial_polar.html">Polar Domain Fitting Tutorial</a> </dd>
<dd>
<a class="el" href="tutorial_sphere.html">Spherical Spline Fitting Tutorial</a> </dd>
<dd>
<a class="el" href="book_reference.html">Book Reference Index</a></dd></dl>
<blockquote class="doxtable">
<p>P. Dierckx, <em>Curve and Surface Fitting with Splines</em>, Oxford University Press, 1993, Chapter 11. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
